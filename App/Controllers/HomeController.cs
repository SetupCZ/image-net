using App.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Library;

namespace App.Controllers;

public class HomeController : Controller
{
    private readonly AppDbContext _context;
    private const int PageSize = 5;

    // Use classic constructor for more complex classes when the readonly is required
    public HomeController(AppDbContext context)
    {
        _context = context;
    }

    public async Task<IActionResult> Index()
    {
        var nodelistEnumerable = GetNodelistEnumerable();
        var root = await GetTree(nodelistEnumerable);

        if (root == null)
        {
            return NotFound();
        }

        return View(root);
    }

    [HttpGet("search")]
    public async Task<IActionResult> SearchTree([FromQuery] string query)
    {
        var nodelistEnumerable = GetFilteredNodelistEnumerable(query);
        var root = await GetTree(nodelistEnumerable);

        if (root == null)
        {
            return View("_Empty");
        }

        return View("_node", root);
    }

    [HttpGet("root")]
    public async Task<IActionResult> Root(CancellationToken cancellationToken)
    {
        var root = await GetRootNode(cancellationToken);

        if (root == null)
        {
            return NotFound();
        }

        var nodes = await GetNodesByParentId(parentId: root.Id, page: null, cancellationToken);

        var pages = GetPages(root);
        var model = new NodeViewModel(root, nodes.ToArray(), pageIndex: 0, pages);

        return View("Index", model);
    }

    [HttpGet("{queryParentId}")]
    public async Task<IActionResult> Categories(
        [FromRoute] Guid queryParentId,
        CancellationToken cancellationToken,
        [FromQuery] int page = 0
    )
    {
        var getParentTask = GetNode(queryParentId, cancellationToken);
        var getNodesTask = GetNodesByParentId(queryParentId, page, cancellationToken);

        await Task.WhenAll(getParentTask, getNodesTask);

        var parent = getParentTask.Result;

        if (parent == null)
        {
            return NotFound();
        }

        var nodes = getNodesTask.Result;

        var pages = GetPages(parent);
        var model = new NodeViewModel(parent, nodes, page, pages);

        return View("_Node", model);
    }

    private static int GetPages(NodeEntity node)
    {
        return (int)Math.Ceiling((decimal)node.Count / PageSize);
    }

    private async Task<NodeEntity?> GetNode(Guid id, CancellationToken cancellationToken)
    {
        return await _context.Nodes.FindAsync([id], cancellationToken: cancellationToken);
    }

    private async Task<NodeEntity?> GetRootNode(CancellationToken cancellationToken)
    {
        return await _context.Nodes.FirstOrDefaultAsync(node => node.ParentId == null,
            cancellationToken: cancellationToken);
    }

    private async Task<NodeEntity[]> GetNodesByParentId(Guid? parentId, int? page, CancellationToken cancellationToken)
    {
        var nodes = await _context.Nodes
            .Where(node => node.ParentId == parentId)
            .OrderBy(node => node.LeftIndex)
            .Skip(PageSize * (page ?? 0))
            .Take(PageSize)
            .ToArrayAsync(cancellationToken: cancellationToken);

        return nodes;
    }

    /*
     * Generates tree from the flat nodes in db.
     * The tree is generated by iterating over the nodes and adding them to the parent node.
     */
    private async Task<NodeViewModel?> GetTree(IAsyncEnumerable<NodeEntity> nodeListEnumerable)
    {
        var rootId = Guid.Empty;
        Dictionary<Guid, NodeViewModel> nodeList = new();

        await foreach (var item in nodeListEnumerable)
        {
            // Find the root node
            if (item.ParentId == null)
            {
                rootId = item.Id;
            }

            var node = new NodeViewModel(item, []);

            if (item.ParentId != null && nodeList.ContainsKey((Guid)item.ParentId))
            {
                var children = nodeList[(Guid)item.ParentId].Children;
                if (!children.Exists(child => child.Node.Id == item.Id))
                {
                    children.Add(node);
                }
            }

            nodeList.TryAdd(item.Id, node);
        }

        return nodeList.GetValueOrDefault(rootId);
    }

    private IAsyncEnumerable<NodeEntity> GetNodelistEnumerable()
    {
        return _context.Nodes.OrderBy(node => node.LeftIndex).AsNoTracking().AsAsyncEnumerable();
    }

    private IAsyncEnumerable<NodeEntity> GetFilteredNodelistEnumerable(string query)
    {
        /*
         * https://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/
         * Selects node and its parent by node name.
         * Each node has a left and right index. The left index is bigger than its parents and the right is smaller.
         */
        return _context.Nodes.FromSqlInterpolated($"""
                                                      SELECT parent.*
                                                      FROM nodes AS node,     
                                                           nodes AS parent
                                                      WHERE 
                                                          node.LeftIndex BETWEEN parent.LeftIndex AND parent.RightIndex
                                                           AND node.Name LIKE {$"%{query}%"} 
                                                           AND node.Name NOT LIKE {$"%{query}%>%"}
                                                      ORDER BY parent.LeftIndex
                                                   """).AsNoTracking().AsAsyncEnumerable();
    }
}
